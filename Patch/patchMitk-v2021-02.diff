diff --git a/CMakeLists.txt b/CMakeLists.txt
index e5bcff7d8b..ef79a9bdba 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -789,6 +789,7 @@ if(NOT MSVC_VERSION)
     -Wno-error=unknown-pragmas
     # The strict-overflow warning is generated by ITK template code
     -Wno-error=strict-overflow
+    -Wno-error=nonnull
     -Woverloaded-virtual
     -Wstrict-null-sentinel
     #-Wold-style-cast
diff --git a/Modules/Annotation/include/mitkColorBarAnnotation.h b/Modules/Annotation/include/mitkColorBarAnnotation.h
index d70f925819..5244f629c2 100644
--- a/Modules/Annotation/include/mitkColorBarAnnotation.h
+++ b/Modules/Annotation/include/mitkColorBarAnnotation.h
@@ -46,7 +46,7 @@ namespace mitk
     itkFactorylessNewMacro(Self);
     itkCloneMacro(Self);
 
-      void SetDrawAnnotations(bool annotations);
+    void SetDrawAnnotations(bool annotations);
     bool GetDrawAnnotations() const;
 
     void SetOrientationToHorizontal();
@@ -69,6 +69,14 @@ namespace mitk
     void SetAnnotationTextScaling(bool scale);
     bool GetAnnotationTextScaling() const;
 
+    void SetFontSize(int s);
+    int GetFontSize() const;
+
+    int GetWidth() const;
+    void SetWidth(int s);
+
+    void SetLength(int s);
+    int GetLenght() const;
   protected:
     /** \brief The LocalStorageHandler holds all LocalStorages for the render windows. */
     mutable mitk::LocalStorageHandler<LocalStorage> m_LSH;
@@ -79,6 +87,8 @@ namespace mitk
     /** \brief explicit constructor which disallows implicit conversions */
     explicit ColorBarAnnotation();
 
+    void Update(mitk::BaseRenderer *renderer) override;
+
     /** \brief virtual destructor in order to derive from this class */
     ~ColorBarAnnotation() override;
 
diff --git a/Modules/Annotation/src/mitkColorBarAnnotation.cpp b/Modules/Annotation/src/mitkColorBarAnnotation.cpp
index 31ee59f04b..40e9aa33da 100644
--- a/Modules/Annotation/src/mitkColorBarAnnotation.cpp
+++ b/Modules/Annotation/src/mitkColorBarAnnotation.cpp
@@ -14,19 +14,24 @@ found in the LICENSE file.
 #include "mitkLookupTable.h"
 #include "mitkLookupTableProperty.h"
 #include <vtkScalarBarActor.h>
+#include <vtkTextProperty.h>
+#include <vtkProperty2D.h>
 
 mitk::ColorBarAnnotation::ColorBarAnnotation()
 {
   SetDrawAnnotations(true);
-
   SetDrawTickLabels(true);
 
   SetOrientationToVertical();
-
   SetMaxNumberOfColors(100);
   SetNumberOfLabels(4);
 
   SetAnnotationTextScaling(false);
+  SetFontSize(8);
+  SetLength(200);
+
+  SetWidth(50);
+  SetColor(0.0, 0.0, 0.0);
 
   SetLookupTable(nullptr);
 }
@@ -42,13 +47,61 @@ mitk::ColorBarAnnotation::~ColorBarAnnotation()
   }
 }
 
-mitk::ColorBarAnnotation::LocalStorage::~LocalStorage()
+mitk::ColorBarAnnotation::LocalStorage::~LocalStorage() {}
+
+void mitk::ColorBarAnnotation::SetFontSize(int s)
+{
+  SetIntProperty("ColorBarAnnotation.Fontsize", s);
+}
+
+int mitk::ColorBarAnnotation::GetFontSize() const
+{
+  int val;
+  GetIntProperty("ColorBarAnnotation.Fontsize", val);
+  return val;
+}
+
+void mitk::ColorBarAnnotation::SetWidth(int s)
+{
+  SetIntProperty("ColorBarAnnotation.Width", s);
+}
+
+int mitk::ColorBarAnnotation::GetWidth() const
 {
+  int val;
+  GetIntProperty("ColorBarAnnotation.Width", val);
+  return val;
+}
+
+void mitk::ColorBarAnnotation::SetLength(int s)
+{
+  SetIntProperty("ColorBarAnnotation.Length", s);
+}
+
+int mitk::ColorBarAnnotation::GetLenght() const
+{
+  int val;
+  GetIntProperty("ColorBarAnnotation.Length", val);
+  return val;
 }
 
 mitk::ColorBarAnnotation::LocalStorage::LocalStorage()
 {
   m_ScalarBarActor = vtkSmartPointer<vtkScalarBarActor>::New();
+  m_ScalarBarActor->SetUnconstrainedFontSize(true);
+  m_ScalarBarActor->GetLabelTextProperty()->SetItalic(0);
+  m_ScalarBarActor->GetLabelTextProperty()->SetShadow(0);
+  m_ScalarBarActor->GetLabelTextProperty()->SetBold(0);
+  double v[3] = {1.0, 1.0, 1.0};
+  m_ScalarBarActor->GetLabelTextProperty()->SetBackgroundColor(v);
+  m_ScalarBarActor->GetLabelTextProperty()->SetBackgroundOpacity(1);
+  m_ScalarBarActor->SetNumberOfLabels(0);
+  // m_ScalarBarActor->SetNumberOf
+}
+
+void mitk::ColorBarAnnotation::Update(mitk::BaseRenderer *renderer)
+{
+  mitk::VtkAnnotation::Update(renderer);
 }
 
 void mitk::ColorBarAnnotation::UpdateVtkAnnotation(mitk::BaseRenderer *renderer)
@@ -64,18 +117,32 @@ void mitk::ColorBarAnnotation::UpdateVtkAnnotation(mitk::BaseRenderer *renderer)
     ls->m_ScalarBarActor->SetMaximumNumberOfColors(this->GetMaxNumberOfColors());
     ls->m_ScalarBarActor->SetNumberOfLabels(this->GetNumberOfLabels());
     ls->m_ScalarBarActor->SetAnnotationTextScaling(this->GetAnnotationTextScaling());
+
+    // ls->m_ScalarBarActor->GetAnnotationTextProperty()->SetFontSize(this->GetFontSize());
+    // ls->m_ScalarBarActor->GetTitleTextProperty()->SetFontSize(this->GetFontSize());
+    ls->m_ScalarBarActor->GetLabelTextProperty()->SetFontSize(this->GetFontSize());
+
+    float color[3];
+    double colord[3];
+    this->GetColor(color);
+    std::copy(color, color + 3, colord);
+    ls->m_ScalarBarActor->GetLabelTextProperty()->SetColor(colord);
+    // ls->m_ScalarBarActor->GetTitleTextProperty()->SetColor(colord);
+    // ls->m_ScalarBarActor->GetAnnotationTextProperty()->SetColor(colord);
+
     // manually set position so there is no overlap with mitk logo in 3d renderwindow
+    auto size = renderer->GetViewportSize();
     if (this->GetOrientation() == 1)
     {
-      ls->m_ScalarBarActor->SetPosition(0.80, 0.15);
-      ls->m_ScalarBarActor->SetWidth(0.15);
-      ls->m_ScalarBarActor->SetHeight(0.85);
+      ls->m_ScalarBarActor->SetPosition(0.05, (1.0 - this->GetLenght() / float(size[1])) * 0.5);
+      ls->m_ScalarBarActor->SetWidth(this->GetWidth() / float(size[0]));
+      ls->m_ScalarBarActor->SetHeight(this->GetLenght() / float(size[1]));
     }
     else
     {
-      ls->m_ScalarBarActor->SetPosition(0.03, 0.03);
-      ls->m_ScalarBarActor->SetWidth(0.8);
-      ls->m_ScalarBarActor->SetHeight(0.15);
+      ls->m_ScalarBarActor->SetPosition((1.0 - this->GetLenght() / float(size[0])) * 0.5, 0.05);
+      ls->m_ScalarBarActor->SetWidth(this->GetLenght() / float(size[0]));
+      ls->m_ScalarBarActor->SetHeight(this->GetWidth() / float(size[1]));
     }
   }
 }
diff --git a/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp b/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp
index d07d3dfb93..b07760c899 100644
--- a/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp
+++ b/Modules/Annotation/src/mitkScaleLegendAnnotation.cpp
@@ -70,6 +70,7 @@ void mitk::ScaleLegendAnnotation::UpdateVtkAnnotation(mitk::BaseRenderer *render
     ls->m_legendScaleActor->GetRightAxis()->SetFontFactor(this->GetFontFactor());
     ls->m_legendScaleActor->GetTopAxis()->SetFontFactor(this->GetFontFactor());
     ls->m_legendScaleActor->GetBottomAxis()->SetFontFactor(this->GetFontFactor());
+    ls->m_legendScaleActor->SetLabelModeToDistance();
   }
 }
 
diff --git a/Modules/Annotation/src/mitkTextAnnotation2D.cpp b/Modules/Annotation/src/mitkTextAnnotation2D.cpp
index 24fab05733..84e029482c 100644
--- a/Modules/Annotation/src/mitkTextAnnotation2D.cpp
+++ b/Modules/Annotation/src/mitkTextAnnotation2D.cpp
@@ -96,13 +96,12 @@ void mitk::TextAnnotation2D::UpdateVtkAnnotation2D(mitk::BaseRenderer *renderer)
     float opacity = 1.0;
     GetColor(color);
     GetOpacity(opacity);
-    ls->m_TextProp->SetColor(color[0], color[1], color[2]);
     ls->m_STextProp->SetColor(0, 0, 0);
-    ls->m_TextProp->SetFontSize(GetFontSize());
-    ls->m_TextProp->SetOpacity(opacity);
     ls->m_STextProp->SetFontSize(GetFontSize());
     ls->m_STextProp->SetOpacity(opacity);
-
+    ls->m_TextProp->SetColor(color[0], color[1], color[2]);
+    ls->m_TextProp->SetFontSize(GetFontSize());
+    ls->m_TextProp->SetOpacity(opacity);
     std::string fontFamilyAsString;
     if (GetStringProperty("font.family", fontFamilyAsString) == false)
     {
diff --git a/Modules/AppUtil/src/mitkBaseApplication.cpp b/Modules/AppUtil/src/mitkBaseApplication.cpp
index e41a40fe79..7c47ea5b01 100644
--- a/Modules/AppUtil/src/mitkBaseApplication.cpp
+++ b/Modules/AppUtil/src/mitkBaseApplication.cpp
@@ -660,6 +660,7 @@ namespace mitk
 #endif
 
       QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);
+      QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
 
       d->m_QApp = this->getSingleMode()
         ? static_cast<QCoreApplication*>(new QmitkSingleApplication(d->m_Argc, d->m_Argv, this->getSafeMode()))
diff --git a/Modules/Core/TestingHelper/include/mitkTestFixture.h b/Modules/Core/TestingHelper/include/mitkTestFixture.h
index f0c881fae8..5bd9c5910a 100644
--- a/Modules/Core/TestingHelper/include/mitkTestFixture.h
+++ b/Modules/Core/TestingHelper/include/mitkTestFixture.h
@@ -111,6 +111,21 @@ namespace mitk
       return std::string(MITK_DATA_DIR) + "/" + testData;
     }
 
+
+    /**
+     * \brief Get the absolute path for project specific test data.
+     *
+     * \param testData The realative path in the project specific test data repository.
+     *
+     * \return The absolute path for the project specific test data.
+     */
+    static std::string GetTestDataFilePath(const std::string &testData, const std::string &project )
+    {
+      if (itksys::SystemTools::FileIsFullPath(testData.c_str()))
+        return testData;
+      return project + "/" + testData;
+    }
+
   private:
     template <class P>
     friend class TestCaller;
diff --git a/Modules/Core/include/mitkLookupTable.h b/Modules/Core/include/mitkLookupTable.h
index 5ab7de7dba..605df41736 100644
--- a/Modules/Core/include/mitkLookupTable.h
+++ b/Modules/Core/include/mitkLookupTable.h
@@ -210,7 +210,10 @@ namespace mitk
       LEGACY_RAINBOW_COLOR,
       MULTILABEL,
       PET_COLOR,
-      PET_20
+      PET_20,
+      GRAYSCALE_TRANSPARENT,
+      HOT_IRON_TRANSPARENT,
+      VIRIDIS_TRANSPARENT
     };
 
     static std::vector<std::string> typenameList;
@@ -244,14 +247,14 @@ namespace mitk
 
     LookupTable(const LookupTable &other);
 
-    virtual void BuildGrayScaleLookupTable();
+    virtual void BuildGrayScaleLookupTable(bool transparent = false);
     virtual void BuildLegacyBinaryLookupTable();
     virtual void BuildLegacyRainbowColorLookupTable();
     virtual void BuildInverseGrayScaleLookupTable();
-    virtual void BuildHotIronLookupTable();
-	  virtual void BuildPlasmaLookupTable();
+    virtual void BuildHotIronLookupTable(bool transparent = false);
+    virtual void BuildPlasmaLookupTable();
 	  virtual void BuildInfernoLookupTable();
-	  virtual void BuildViridisLookupTable();
+    virtual void BuildViridisLookupTable(bool transparent = false);
     virtual void BuildMagmaLookupTable();
     virtual void BuildJetLookupTable(bool transparent = false);
     virtual void BuildPETColorLookupTable();
diff --git a/Modules/Core/src/DataManagement/mitkImage.cpp b/Modules/Core/src/DataManagement/mitkImage.cpp
index 4ed855b751..381bd0aebe 100644
--- a/Modules/Core/src/DataManagement/mitkImage.cpp
+++ b/Modules/Core/src/DataManagement/mitkImage.cpp
@@ -939,7 +939,7 @@ void mitk::Image::Initialize(const mitk::PixelType &type,
   dimensions[4] = 0;
 
   unsigned int dimension = 2;
-  if (dimensions[2] > 1)
+  if (dimensions[2] >= 1)
     dimension = 3;
   if (dimensions[3] > 1)
     dimension = 4;
diff --git a/Modules/Core/src/DataManagement/mitkImageCastPart4.cpp b/Modules/Core/src/DataManagement/mitkImageCastPart4.cpp
index 5c4786a10a..4ff01ced03 100644
--- a/Modules/Core/src/DataManagement/mitkImageCastPart4.cpp
+++ b/Modules/Core/src/DataManagement/mitkImageCastPart4.cpp
@@ -18,6 +18,7 @@ found in the LICENSE file.
 namespace mitk
 {
   typedef itk::Image<itk::RGBPixel<unsigned char>, 2> itkImageRGBUC2;
+  typedef itk::Image<itk::RGBAPixel<unsigned char>, 2> itkImageRGBAUC2;
   typedef itk::Image<itk::DiffusionTensor3D<float>, 2> itkImageDTIF2;
   typedef itk::Image<itk::DiffusionTensor3D<double>, 2> itkImageDTID2;
 
@@ -32,6 +33,16 @@ namespace mitk
                            itkOutputImage);
   }
   template <>
+  void MITKCORE_EXPORT CastToItkImage(const mitk::Image *mitkImage, itk::SmartPointer<itkImageRGBAUC2> &itkOutputImage)
+  {
+    typedef itkImageRGBAUC2 ItkOutputImageType;
+    AccessFixedTypeByItk_1(mitkImage,
+                           _CastToItkImage2Access,
+                           (itk::RGBAPixel<unsigned char>),
+                           (ItkOutputImageType::ImageDimension),
+                           itkOutputImage);
+  }
+  template <>
   void MITKCORE_EXPORT CastToItkImage(const mitk::Image *mitkImage, itk::SmartPointer<itkImageDTIF2> &itkOutputImage)
   {
     typedef itkImageDTIF2 ItkOutputImageType;
diff --git a/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp b/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp
index c0b04c6570..f8ac8f7d8d 100644
--- a/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp
+++ b/Modules/Core/src/DataManagement/mitkLevelWindowManager.cpp
@@ -555,7 +555,8 @@ mitk::DataStorage::SetOfObjects::ConstPointer mitk::LevelWindowManager::GetRelev
   NodePredicateProperty::Pointer notBinary = NodePredicateProperty::New("binary", BoolProperty::New(false));
   NodePredicateProperty::Pointer hasLevelWindow = NodePredicateProperty::New("levelwindow", nullptr);
 
-  NodePredicateDataType::Pointer isImage = NodePredicateDataType::New("Image");
+  //NodePredicateDataType::Pointer isImage = NodePredicateDataType::New("Image");
+  auto isImage = TNodePredicateDataType<mitk::Image>::New();
   NodePredicateDataType::Pointer isDImage = NodePredicateDataType::New("DiffusionImage");
   NodePredicateDataType::Pointer isTImage = NodePredicateDataType::New("TensorImage");
   NodePredicateDataType::Pointer isOdfImage = NodePredicateDataType::New("OdfImage");
diff --git a/Modules/Core/src/DataManagement/mitkLookupTable.cpp b/Modules/Core/src/DataManagement/mitkLookupTable.cpp
index 3022e09869..613c2f7249 100644
--- a/Modules/Core/src/DataManagement/mitkLookupTable.cpp
+++ b/Modules/Core/src/DataManagement/mitkLookupTable.cpp
@@ -17,57 +17,56 @@ found in the LICENSE file.
 #include <vtkPiecewiseFunction.h>
 
 #include <Colortables/HotIron.h>
-#include <Colortables/Jet.h>
 #include <Colortables/Inferno.h>
-#include <Colortables/Viridis.h>
-#include <Colortables/Plasma.h>
+#include <Colortables/Jet.h>
 #include <Colortables/Magma.h>
 #include <Colortables/Multilabel.h>
 #include <Colortables/PET20.h>
 #include <Colortables/PETColor.h>
+#include <Colortables/Plasma.h>
+#include <Colortables/Viridis.h>
 #include <mitkLookupTableProperty.h>
 
-std::vector<std::string> mitk::LookupTable::typenameList = {
-  "Grayscale",
-  "Inverse Grayscale",
-  "Hot Iron",
-  "Jet",
-  "Jet Transparent",
-  "Plasma",
-  "Inferno",
-  "Viridis",
-  "Magma",
-  "Legacy Binary",
-  "Legacy Rainbow Color",
-  "Multilabel",
-  "PET Color",
-  "PET 20"
-};
+std::vector<std::string> mitk::LookupTable::typenameList = {"Grayscale",
+                                                            "Inverse Grayscale",
+                                                            "Hot Iron",
+                                                            "Jet",
+                                                            "Jet Transparent",
+                                                            "Plasma",
+                                                            "Inferno",
+                                                            "Viridis",
+                                                            "Magma",
+                                                            "Legacy Binary",
+                                                            "Legacy Rainbow Color",
+                                                            "Multilabel",
+                                                            "PET Color",
+                                                            "PET 20",
+                                                            "Grayscale Transparent",
+                                                            "Hot Iron Transparent",
+                                                            "Viridis Transparent"};
 
 mitk::LookupTable::LookupTable()
-  : m_LookupTable(vtkSmartPointer<vtkLookupTable>::New())
-  , m_Window(0.0)
-  , m_Level(0.0)
-  , m_Opacity(1.0)
-  , m_Type(mitk::LookupTable::GRAYSCALE)
+  : m_LookupTable(vtkSmartPointer<vtkLookupTable>::New()),
+    m_Window(0.0),
+    m_Level(0.0),
+    m_Opacity(1.0),
+    m_Type(mitk::LookupTable::GRAYSCALE)
 {
   this->BuildGrayScaleLookupTable();
 }
 
 mitk::LookupTable::LookupTable(const LookupTable &other)
-  : itk::DataObject()
-  , m_LookupTable(vtkSmartPointer<vtkLookupTable>::New())
-  , m_Window(other.m_Window)
-  , m_Level(other.m_Level)
-  , m_Opacity(other.m_Opacity)
-  , m_Type(other.m_Type)
+  : itk::DataObject(),
+    m_LookupTable(vtkSmartPointer<vtkLookupTable>::New()),
+    m_Window(other.m_Window),
+    m_Level(other.m_Level),
+    m_Opacity(other.m_Opacity),
+    m_Type(other.m_Type)
 {
   m_LookupTable->DeepCopy(other.m_LookupTable);
 }
 
-mitk::LookupTable::~LookupTable()
-{
-}
+mitk::LookupTable::~LookupTable() {}
 
 void mitk::LookupTable::SetVtkLookupTable(vtkSmartPointer<vtkLookupTable> lut)
 {
@@ -87,6 +86,9 @@ void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
 
   switch (type)
   {
+    case (mitk::LookupTable::GRAYSCALE_TRANSPARENT):
+      this->BuildGrayScaleLookupTable(true);
+      break;
     case (mitk::LookupTable::GRAYSCALE):
       this->BuildGrayScaleLookupTable();
       break;
@@ -96,6 +98,9 @@ void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
     case (mitk::LookupTable::HOT_IRON):
       this->BuildHotIronLookupTable();
       break;
+    case (mitk::LookupTable::HOT_IRON_TRANSPARENT):
+      this->BuildHotIronLookupTable(true);
+      break;
     case (mitk::LookupTable::JET):
       this->BuildJetLookupTable();
       break;
@@ -103,14 +108,17 @@ void mitk::LookupTable::SetType(const mitk::LookupTable::LookupTableType type)
       this->BuildJetLookupTable(true);
       break;
     case (mitk::LookupTable::PLASMA):
-	    this->BuildPlasmaLookupTable();
-	    break;
-	  case (mitk::LookupTable::INFERNO):
-	    this->BuildInfernoLookupTable();
+      this->BuildPlasmaLookupTable();
+      break;
+    case (mitk::LookupTable::INFERNO):
+      this->BuildInfernoLookupTable();
+      break;
+    case (mitk::LookupTable::VIRIDIS):
+      this->BuildViridisLookupTable();
+      break;
+    case (mitk::LookupTable::VIRIDIS_TRANSPARENT):
+      this->BuildViridisLookupTable(true);
       break;
-	  case (mitk::LookupTable::VIRIDIS):
-	    this->BuildViridisLookupTable();
-	    break;
     case (mitk::LookupTable::MAGMA):
       this->BuildMagmaLookupTable();
       break;
@@ -285,9 +293,7 @@ void mitk::LookupTable::UpdateOutputInformation()
   }
 }
 
-void mitk::LookupTable::SetRequestedRegionToLargestPossibleRegion()
-{
-}
+void mitk::LookupTable::SetRequestedRegionToLargestPossibleRegion() {}
 
 bool mitk::LookupTable::RequestedRegionIsOutsideOfTheBufferedRegion()
 {
@@ -411,7 +417,7 @@ itk::LightObject::Pointer mitk::LookupTable::InternalClone() const
   return result;
 }
 
-void mitk::LookupTable::BuildGrayScaleLookupTable()
+void mitk::LookupTable::BuildGrayScaleLookupTable(bool transparent)
 {
   vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
   lut->SetRampToLinear();
@@ -420,6 +426,11 @@ void mitk::LookupTable::BuildGrayScaleLookupTable()
   lut->SetValueRange(0.0, 1.0);
   lut->Build();
 
+  if (transparent)
+  {
+    lut->SetTableValue(0, 0.0, 0.0, 0.0, 0.0);
+  }
+
   m_LookupTable = lut;
   this->Modified();
 }
@@ -452,13 +463,22 @@ void mitk::LookupTable::BuildInverseGrayScaleLookupTable()
   this->Modified();
 }
 
-void mitk::LookupTable::BuildHotIronLookupTable()
+void mitk::LookupTable::BuildHotIronLookupTable(bool transparent)
 {
   vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
   lut->SetNumberOfTableValues(256);
   lut->Build();
+  int i = 0;
 
-  for (int i = 0; i < 256; i++)
+  if (transparent)
+  {
+    // Lowest intensity is transparent
+    lut->SetTableValue(
+      0, (double)HotIron[0][0] / 255.0, (double)HotIron[0][1] / 255.0, (double)HotIron[0][2] / 255.0, 0.0);
+    i = 1;
+  }
+
+  for (; i < 256; i++)
   {
     lut->SetTableValue(
       i, (double)HotIron[i][0] / 255.0, (double)HotIron[i][1] / 255.0, (double)HotIron[i][2] / 255.0, 1.0);
@@ -535,7 +555,7 @@ void mitk::LookupTable::BuildMultiLabelLookupTable()
 
   for (int i = 0; i < 25; i++)
   {
-    lut->SetTableValue(i+1, Multilabel[i][0], Multilabel[i][1], Multilabel[i][2], 0.4);
+    lut->SetTableValue(i + 1, Multilabel[i][0], Multilabel[i][1], Multilabel[i][2], 0.4);
   }
 
   for (int i = 26; i < 65536; i++)
@@ -584,50 +604,59 @@ void mitk::LookupTable::BuildLegacyRainbowColorLookupTable()
 
 void mitk::LookupTable::BuildPlasmaLookupTable()
 {
-	vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
-	lut->SetNumberOfTableValues(256);
-	lut->Build();
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
 
-	for (int i = 0; i < 256; i++)
-	{
-		lut->SetTableValue(
-			i, (double)Plasma[i][0] / 255.0, (double)Plasma[i][1] / 255.0, (double)Plasma[i][2] / 255.0, 1.0);
-	}
+  for (int i = 0; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Plasma[i][0] / 255.0, (double)Plasma[i][1] / 255.0, (double)Plasma[i][2] / 255.0, 1.0);
+  }
 
-	m_LookupTable = lut;
-	this->Modified();
+  m_LookupTable = lut;
+  this->Modified();
 }
 
 void mitk::LookupTable::BuildInfernoLookupTable()
 {
-	vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
-	lut->SetNumberOfTableValues(256);
-	lut->Build();
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
 
-	for (int i = 0; i < 256; i++)
-	{
-		lut->SetTableValue(
-			i, (double)Inferno[i][0] / 255.0, (double)Inferno[i][1] / 255.0, (double)Inferno[i][2] / 255.0, 1.0);
-	}
+  for (int i = 0; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Inferno[i][0] / 255.0, (double)Inferno[i][1] / 255.0, (double)Inferno[i][2] / 255.0, 1.0);
+  }
 
-	m_LookupTable = lut;
-	this->Modified();
+  m_LookupTable = lut;
+  this->Modified();
 }
 
-void mitk::LookupTable::BuildViridisLookupTable()
+void mitk::LookupTable::BuildViridisLookupTable(bool transparent)
 {
-	vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
-	lut->SetNumberOfTableValues(256);
-	lut->Build();
+  vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
+  lut->SetNumberOfTableValues(256);
+  lut->Build();
+
+  int i = 0;
+  if (transparent)
+  {
+    // Lowest intensity is transparent
+    lut->SetTableValue(
+      0, (double)Viridis[0][0] / 255.0, (double)Viridis[0][1] / 255.0, (double)Viridis[0][2] / 255.0, 0.0);
+    i = 1;
+  }
 
-	for (int i = 0; i < 256; i++)
-	{
-		lut->SetTableValue(
-			i, (double)Viridis[i][0] / 255.0, (double)Viridis[i][1] / 255.0, (double)Viridis[i][2] / 255.0, 1.0);
-	}
+  for (; i < 256; i++)
+  {
+    lut->SetTableValue(
+      i, (double)Viridis[i][0] / 255.0, (double)Viridis[i][1] / 255.0, (double)Viridis[i][2] / 255.0, 1.0);
+  }
 
-	m_LookupTable = lut;
-	this->Modified();
+  m_LookupTable = lut;
+  this->Modified();
 }
 
 void mitk::LookupTable::BuildMagmaLookupTable()
@@ -638,8 +667,7 @@ void mitk::LookupTable::BuildMagmaLookupTable()
 
   for (int i = 0; i < 256; i++)
   {
-    lut->SetTableValue(
-      i, (double)Magma[i][0] / 255.0, (double)Magma[i][1] / 255.0, (double)Magma[i][2] / 255.0, 1.0);
+    lut->SetTableValue(i, (double)Magma[i][0] / 255.0, (double)Magma[i][1] / 255.0, (double)Magma[i][2] / 255.0, 1.0);
   }
 
   m_LookupTable = lut;
diff --git a/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp b/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp
index cfecd85744..8c40ae6d85 100644
--- a/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp
+++ b/Modules/Core/src/Interactions/mitkPointSetDataInteractor.cpp
@@ -147,7 +147,7 @@ void mitk::PointSetDataInteractor::SelectPoint(StateMachineAction *, Interaction
   }
 }
 
-mitk::PointSetDataInteractor::PointSetDataInteractor() : m_MaxNumberOfPoints(0), m_SelectionAccuracy(3.5)
+mitk::PointSetDataInteractor::PointSetDataInteractor() : m_MaxNumberOfPoints(0), m_SelectionAccuracy(0.025)
 {
 }
 
diff --git a/Modules/CppMicroServices/third_party/jsoncpp.cpp b/Modules/CppMicroServices/third_party/jsoncpp.cpp
index e4d9ea08a6..d029e60b4a 100644
--- a/Modules/CppMicroServices/third_party/jsoncpp.cpp
+++ b/Modules/CppMicroServices/third_party/jsoncpp.cpp
@@ -1725,7 +1725,7 @@ Value::CZString::operator =( const CZString &other )
 bool
 Value::CZString::operator<( const CZString &other ) const
 {
-   if ( cstr_ )
+   if ( cstr_ && other.cstr_)
       return strcmp( cstr_, other.cstr_ ) < 0;
    return index_ < other.index_;
 }
@@ -1733,7 +1733,7 @@ Value::CZString::operator<( const CZString &other ) const
 bool
 Value::CZString::operator==( const CZString &other ) const
 {
-   if ( cstr_ )
+   if ( cstr_ && other.cstr_)
       return strcmp( cstr_, other.cstr_ ) == 0;
    return index_ == other.index_;
 }
diff --git a/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp b/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp
index 623924f0b3..f549e3610a 100644
--- a/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp
+++ b/Modules/ImageStatistics/mitkImageStatisticsPredicateHelper.cpp
@@ -17,6 +17,7 @@ found in the LICENSE file.
 #include <mitkNodePredicateDataType.h>
 #include <mitkNodePredicateProperty.h>
 #include <mitkNodePredicateNot.h>
+#include <mitkImage.h>
 
 namespace mitk
 {
@@ -30,7 +31,7 @@ namespace mitk
 
   mitk::NodePredicateBase::Pointer GetImageStatisticsImagePredicate()
   {
-    auto isImage = mitk::NodePredicateDataType::New("Image");
+    auto isImage = mitk::TNodePredicateDataType<mitk::Image>::New();
     auto hasBinaryProperty = mitk::NodePredicateProperty::New("binary", mitk::BoolProperty::New(true));
     auto isNotBinary = mitk::NodePredicateNot::New(hasBinaryProperty);
     auto isNotBinaryImage = mitk::NodePredicateAnd::New(isImage, isNotBinary);
diff --git a/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp b/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp
index 46a8600375..9b555c7fe6 100644
--- a/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp
+++ b/Modules/QtWidgets/src/QmitkNodeDescriptorManager.cpp
@@ -13,10 +13,12 @@ found in the LICENSE file.
 #include "QmitkNodeDescriptorManager.h"
 #include <memory>
 #include <mitkNodePredicateAnd.h>
+#include <mitkNodePredicateOr.h>
 #include <mitkNodePredicateDataType.h>
 #include <mitkNodePredicateNot.h>
 #include <mitkNodePredicateProperty.h>
 #include <mitkProperties.h>
+#include <mitkImage.h>
 
 #include <QList>
 #include <QSet>
@@ -35,6 +37,13 @@ void QmitkNodeDescriptorManager::Initialize()
   auto isMultiComponentImage = mitk::NodePredicateAnd::New(isImage, mitk::NodePredicateProperty::New("Image.Displayed Component"));
   AddDescriptor(new QmitkNodeDescriptor(tr("MultiComponentImage"), QString(": / Qmitk / Images_48.png"), isMultiComponentImage, this));
 
+  auto a = mitk::NodePredicateDataType::New("SpectrumImageBase");
+  auto b = mitk::NodePredicateDataType::New("ImzMLSpectrumImage");
+  auto c = mitk::NodePredicateOr::New(a, b);
+  auto f = mitk::TNodePredicateDataType<mitk::Image>::New();
+  auto g = mitk::NodePredicateAnd::New(c, f);
+  AddDescriptor( new QmitkNodeDescriptor(tr("SpectrumImage"), QString(":/Qmitk/LabelSetImage_48.png"), g, this));
+
   auto isBinary = mitk::NodePredicateProperty::New("binary", mitk::BoolProperty::New(true));
   auto isBinaryImage = mitk::NodePredicateAnd::New(isBinary, isImage);
   AddDescriptor(new QmitkNodeDescriptor(tr("ImageMask"), QString(":/Qmitk/Binaerbilder_48.png"), isBinaryImage, this));
diff --git a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp
index a8a7e00ce6..a431349cc0 100644
--- a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp
+++ b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.cpp
@@ -11,7 +11,16 @@ found in the LICENSE file.
 ============================================================================*/
 
 #include <QmitkDataNodeContextMenu.h>
+#include "QmitkDataNodeContextMenu.h"
 
+// mitk gui qt application plugin
+#include "QmitkFileSaveAction.h"
+#include "mitkIContextMenuAction.h"
+
+// mitk gui common plugin
+#include <mitkDataNodeSelection.h>
+
+// qt widgets module
 #include <QmitkCustomVariants.h>
 #include <QmitkFileSaveAction.h>
 #include <QmitkNodeDescriptorManager.h>
@@ -101,6 +110,8 @@ void QmitkDataNodeContextMenu::InitNodeDescriptors()
   m_PlanarDoubleEllipseNodeDescriptor = nodeDescriptorManager->GetDescriptor("PlanarDoubleEllipse");
   m_PlanarBezierCurveNodeDescriptor = nodeDescriptorManager->GetDescriptor("PlanarBezierCurve");
   m_PlanarSubdivisionPolygonNodeDescriptor = nodeDescriptorManager->GetDescriptor("PlanarSubdivisionPolygon");
+  m_ImzMLMassSpecImageNodeDescriptor = nodeDescriptorManager->GetDescriptor("SpectrumImage");
+
 }
 
 void QmitkDataNodeContextMenu::InitDefaultActions()
@@ -145,48 +156,49 @@ void QmitkDataNodeContextMenu::InitDefaultActions()
   m_UnknownDataNodeDescriptor->AddAction(m_OpacityAction, false);
   m_DescriptorActionList.push_back(std::make_pair(m_UnknownDataNodeDescriptor, m_OpacityAction));
 
-  m_ColorAction = new QmitkDataNodeColorAction(m_Parent, workbenchPartSite);
-  this->AddColorAction(m_ColorAction);
-
-  m_ColormapAction = new QmitkDataNodeColorMapAction(m_Parent, workbenchPartSite);
-  m_ImageDataNodeDescriptor->AddAction(m_ColormapAction);
-  m_DescriptorActionList.push_back(std::make_pair(m_ImageDataNodeDescriptor, m_ColormapAction));
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(m_ColormapAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, m_ColormapAction));
-  }
-
-  m_ComponentAction = new QmitkDataNodeComponentAction(m_Parent, workbenchPartSite);
-  m_MultiComponentImageDataNodeDescriptor->AddAction(m_ComponentAction, false);
-  m_DescriptorActionList.push_back(std::make_pair(m_MultiComponentImageDataNodeDescriptor, m_ComponentAction));
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(m_ComponentAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, m_ComponentAction));
-  }
-
-  m_TextureInterpolationAction = new QmitkDataNodeTextureInterpolationAction(m_Parent, workbenchPartSite);
-  m_ImageDataNodeDescriptor->AddAction(m_TextureInterpolationAction, false);
-  m_DescriptorActionList.push_back(std::make_pair(m_ImageDataNodeDescriptor, m_TextureInterpolationAction));
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(m_TextureInterpolationAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, m_TextureInterpolationAction));
-  }
-
-  if (nullptr != m_SegmentDataNodeDescriptor)
-  {
-    m_SegmentDataNodeDescriptor->AddAction(m_TextureInterpolationAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_SegmentDataNodeDescriptor, m_TextureInterpolationAction));
-  }
+  auto all = {m_ImageDataNodeDescriptor,
+              m_ImzMLMassSpecImageNodeDescriptor,
+              m_MultiComponentImageDataNodeDescriptor,
+              m_DiffusionImageDataNodeDescriptor,
+              m_FiberBundleDataNodeDescriptor,
+              m_PeakImageDataNodeDescriptor,
+              m_SegmentDataNodeDescriptor,
+              m_SurfaceDataNodeDescriptor,
+              m_PointSetNodeDescriptor,
+              m_PlanarLineNodeDescriptor,
+              m_PlanarCircleNodeDescriptor,
+              m_PlanarEllipseNodeDescriptor,
+              m_PlanarAngleNodeDescriptor,
+              m_PlanarFourPointAngleNodeDescriptor,
+              m_PlanarRectangleNodeDescriptor,
+              m_PlanarPolygonNodeDescriptor,
+              m_PlanarPathNodeDescriptor,
+              m_PlanarDoubleEllipseNodeDescriptor,
+              m_PlanarBezierCurveNodeDescriptor,
+              m_PlanarSubdivisionPolygonNodeDescriptor};
+
+  m_ColorAction = new QmitkDataNodeColorAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_ColorAction, all, true);
+
+  m_ColormapAction = new QmitkDataNodeColorMapAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_ColormapAction,
+            {m_ImageDataNodeDescriptor, m_DiffusionImageDataNodeDescriptor, m_ImzMLMassSpecImageNodeDescriptor},
+            true);
+
+  m_ComponentAction = new QmitkDataNodeComponentAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_ComponentAction, {m_MultiComponentImageDataNodeDescriptor, m_DiffusionImageDataNodeDescriptor}, false);
+
+  m_TextureInterpolationAction = new QmitkDataNodeTextureInterpolationAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_TextureInterpolationAction,
+            {m_ImageDataNodeDescriptor,
+             m_DiffusionImageDataNodeDescriptor,
+             m_ImzMLMassSpecImageNodeDescriptor,
+             m_SegmentDataNodeDescriptor},
+            false);
+
+  m_SurfaceRepresentationAction = new QmitkDataNodeSurfaceRepresentationAction(m_Parent, m_WorkbenchPartSite.Lock());
+  AddAction(m_SurfaceRepresentationAction, {m_SurfaceDataNodeDescriptor}, false);
 
-  m_SurfaceRepresentationAction = new QmitkDataNodeSurfaceRepresentationAction(m_Parent, workbenchPartSite);
-  m_SurfaceDataNodeDescriptor->AddAction(m_SurfaceRepresentationAction, false);
-  m_DescriptorActionList.push_back(std::make_pair(m_SurfaceDataNodeDescriptor, m_SurfaceRepresentationAction));
 }
 
 void QmitkDataNodeContextMenu::InitExtensionPointActions()
@@ -194,7 +206,9 @@ void QmitkDataNodeContextMenu::InitExtensionPointActions()
   auto extensionPointService = berry::Platform::GetExtensionRegistry();
   auto customMenuConfigs = extensionPointService->GetConfigurationElementsFor("org.mitk.gui.qt.datamanager.contextMenuActions");
 
+
   DescriptorActionListType descriptorActionList;
+
   m_ConfigElements.clear();
 
   for (const auto& customMenuConfig : qAsConst(customMenuConfigs))
@@ -310,125 +324,22 @@ void QmitkDataNodeContextMenu::OnExtensionPointActionTriggered(QAction* action)
   contextMenuAction->Run(m_SelectedNodes);
 }
 
-void QmitkDataNodeContextMenu::AddColorAction(QWidgetAction* colorAction)
+void QmitkDataNodeContextMenu::AddAction(QAction *action, std::vector<QmitkNodeDescriptor *> list, bool canBatch)
 {
-  if (nullptr != m_ImageDataNodeDescriptor)
-  {
-    m_ImageDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_ImageDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_MultiComponentImageDataNodeDescriptor)
-  {
-    m_MultiComponentImageDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_MultiComponentImageDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_DiffusionImageDataNodeDescriptor)
-  {
-    m_DiffusionImageDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_DiffusionImageDataNodeDescriptor, colorAction));
-  }
 
-  if (nullptr != m_FiberBundleDataNodeDescriptor)
+  for (auto *descriptor : list)
   {
-    m_FiberBundleDataNodeDescriptor->AddAction(colorAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_FiberBundleDataNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PeakImageDataNodeDescriptor)
+    if (nullptr != descriptor)
   {
-    m_PeakImageDataNodeDescriptor->AddAction(colorAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_PeakImageDataNodeDescriptor, colorAction));
+      descriptor->AddAction(action, canBatch);
+      m_DescriptorActionList.push_back(std::make_pair(descriptor, action));
   }
-
-  if (nullptr != m_SegmentDataNodeDescriptor)
-  {
-    m_SegmentDataNodeDescriptor->AddAction(colorAction, false);
-    m_DescriptorActionList.push_back(std::make_pair(m_SegmentDataNodeDescriptor, colorAction));
   }
-
-  if (nullptr != m_SurfaceDataNodeDescriptor)
-  {
-    m_SurfaceDataNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_SurfaceDataNodeDescriptor, colorAction));
   }
 
-  if (nullptr != m_PointSetNodeDescriptor)
+void QmitkDataNodeContextMenu::AddDescriptorActionList(DescriptorActionListType &descriptorActionList)
   {
-    m_PointSetNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PointSetNodeDescriptor, colorAction));
-  }
 
-  if (nullptr != m_PlanarLineNodeDescriptor)
-  {
-    m_PlanarLineNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarLineNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarCircleNodeDescriptor)
-  {
-    m_PlanarCircleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarCircleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarEllipseNodeDescriptor)
-  {
-    m_PlanarEllipseNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarEllipseNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarAngleNodeDescriptor)
-  {
-    m_PlanarAngleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarAngleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarFourPointAngleNodeDescriptor)
-  {
-    m_PlanarFourPointAngleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarFourPointAngleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarRectangleNodeDescriptor)
-  {
-    m_PlanarRectangleNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarRectangleNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarPolygonNodeDescriptor)
-  {
-    m_PlanarPolygonNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarPolygonNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarPathNodeDescriptor)
-  {
-    m_PlanarPathNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarPathNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarDoubleEllipseNodeDescriptor)
-  {
-    m_PlanarDoubleEllipseNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarDoubleEllipseNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarBezierCurveNodeDescriptor)
-  {
-    m_PlanarBezierCurveNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarBezierCurveNodeDescriptor, colorAction));
-  }
-
-  if (nullptr != m_PlanarSubdivisionPolygonNodeDescriptor)
-  {
-    m_PlanarSubdivisionPolygonNodeDescriptor->AddAction(colorAction, true);
-    m_DescriptorActionList.push_back(std::make_pair(m_PlanarSubdivisionPolygonNodeDescriptor, colorAction));
-  }
-}
-
-void QmitkDataNodeContextMenu::AddDescriptorActionList(DescriptorActionListType& descriptorActionList)
-{
   using ListItem = std::pair<QmitkNodeDescriptor*, QAction*>;
 
   std::sort(descriptorActionList.begin(), descriptorActionList.end(), [](const ListItem& left, const ListItem& right) -> bool
diff --git a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h
index 2dcf8ba901..3428e42c02 100644
--- a/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h
+++ b/Plugins/org.mitk.gui.qt.application/src/QmitkDataNodeContextMenu.h
@@ -74,7 +74,7 @@ private:
   void InitExtensionPointActions();
   void InitServiceActions();
 
-  void AddColorAction(QWidgetAction* colorAction);
+  void AddAction(QAction *colorAction, std::vector<QmitkNodeDescriptor *> list, bool canBatch = false);
   void AddDescriptorActionList(DescriptorActionListType& descriptorActionList);
 
   QList<QAction*> GetActions(const mitk::DataNode* node);
@@ -113,6 +113,7 @@ private:
   QmitkNodeDescriptor* m_PlanarDoubleEllipseNodeDescriptor;
   QmitkNodeDescriptor* m_PlanarBezierCurveNodeDescriptor;
   QmitkNodeDescriptor* m_PlanarSubdivisionPolygonNodeDescriptor;
+  QmitkNodeDescriptor* m_ImzMLMassSpecImageNodeDescriptor;
 
   //////////////////////////////////////////////////////////////////////////
   // default actions
diff --git a/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp b/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp
index d301680b15..61665c7e4f 100644
--- a/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp
+++ b/Plugins/org.mitk.gui.qt.common/src/QmitkMultiWidgetDecorationManager.cpp
@@ -159,7 +159,7 @@ void QmitkMultiWidgetDecorationManager::SetupLogo(const char* path)
   mitk::Point2D offset;
   offset.Fill(0.03);
   m_LogoAnnotation->SetOffsetVector(offset);
-  m_LogoAnnotation->SetRelativeSize(0.25);
+  m_LogoAnnotation->SetRelativeSize(0.15);
   m_LogoAnnotation->SetCornerPosition(1);
   vtkSmartPointer<vtkImageData> vtkLogo = GetVtkLogo(path);
 
diff --git a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp
index dfbd27ae6a..adbbb9ced7 100755
--- a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp
+++ b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.cpp
@@ -34,6 +34,13 @@ QmitkPointSetInteractionView::~QmitkPointSetInteractionView()
 {
 }
 
+void QmitkPointSetInteractionView::OnSelectionChanged(berry::IWorkbenchPart::Pointer /*source*/,
+                                                      const QList<mitk::DataNode::Pointer> &nodes)
+{
+  if(nodes.size() == 1)
+    m_Controls->selectedPointSetWidget->SetCurrentSelectedNode(nodes.front());
+}
+
 void QmitkPointSetInteractionView::CreateQtPartControl(QWidget *parent)
 {
   m_Controls = new Ui::QmitkPointSetInteractionViewControls;
@@ -47,7 +54,7 @@ void QmitkPointSetInteractionView::CreateQtPartControl(QWidget *parent)
       mitk::NodePredicateProperty::New("hidden object")))));
 
   m_Controls->selectedPointSetWidget->SetSelectionIsOptional(true);
-  m_Controls->selectedPointSetWidget->SetAutoSelectNewNodes(true);
+  m_Controls->selectedPointSetWidget->SetAutoSelectNewNodes(false);
   m_Controls->selectedPointSetWidget->SetEmptyInfo(QString("Please select a point set"));
   m_Controls->selectedPointSetWidget->SetPopUpTitel(QString("Select point set"));
 
diff --git a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.h b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.h
index c7bc89fc2e..9ab7f94d0b 100755
--- a/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.h
+++ b/Plugins/org.mitk.gui.qt.pointsetinteraction/src/internal/QmitkPointSetInteractionView.h
@@ -45,6 +45,8 @@ private Q_SLOT:
 private:
 
   void CreateQtPartControl(QWidget *parent) override;
+  void OnSelectionChanged(berry::IWorkbenchPart::Pointer /*source*/,
+                                    const QList<mitk::DataNode::Pointer> &nodes);
 
   Ui::QmitkPointSetInteractionViewControls* m_Controls;
 
diff --git a/SuperBuild.cmake b/SuperBuild.cmake
index b83484ef43..22d104a7d2 100644
--- a/SuperBuild.cmake
+++ b/SuperBuild.cmake
@@ -211,6 +211,22 @@ set(mitk_depends )
 
 # Include external projects
 include(CMakeExternals/MITKData.cmake)
+
+
+foreach(MITK_EXTENSION_DIR ${MITK_EXTENSION_DIRS})
+  set(MITK_CMAKE_EXTERNALS_EXTENSION_DIR ${MITK_EXTENSION_DIR}/CMakeExternals)
+  get_filename_component(MITK_CMAKE_EXTERNALS_EXTENSION_DIR ${MITK_CMAKE_EXTERNALS_EXTENSION_DIR} ABSOLUTE)
+  FILE(GLOB MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILES ${MITK_CMAKE_EXTERNALS_EXTENSION_DIR}/*Data.cmake)
+  foreach(MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILE ${MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILES})
+    if(EXISTS ${MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILE})
+        include(${MITK_CMAKE_EXTERNALS_EXTENSION_TESTDATA_FILE})
+    endif()
+  endforeach()
+endforeach()
+
+
+
+
 foreach(p ${external_projects})
   set(p_hash "")
 
